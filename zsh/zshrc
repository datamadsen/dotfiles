# Path to the directory of the zshrc file. This path is filled in install.sh
# initially, and then by git filters.
zsh_config_dir=

export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8

setopt prompt_subst
autoload -U colors && colors
autoload -U compinit && compinit

source $zsh_config_dir/git-prompt.sh
local gitval='$(__git_ps1 "(%s)")'

prompt="%{$fg[yellow]%}%n@%m %{$fg[blue]%}%~ %{$fg[green]%}${gitval}
%{$fg[red]%}$ %{$reset_color%}"

gb() {
    if [ $1 = "on" ]; then
        export GIT_PS1_SHOWDIRTYSTATE=
        export GIT_PS1_SHOWSTASHSTATE=
        export GIT_PS1_SHOWUNTRACKEDFILES=
        export GIT_PS1_SHOWUPSTREAM=
prompt="%{$fg[yellow]%}%n@%m %{$fg[blue]%}%~ %{$fg[green]%}${gitval}
%{$fg[red]%}$ %{$reset_color%}"
    elif [ $1 = "off" ]; then
prompt="%{$fg[yellow]%}%n@%m %{$fg[blue]%}%~ 
%{$fg[red]%}$ %{$reset_color%}"
    elif [ $1 = "all" ]; then
        export GIT_PS1_SHOWDIRTYSTATE=1
        export GIT_PS1_SHOWSTASHSTATE=1
        export GIT_PS1_SHOWUNTRACKEDFILES=1
        export GIT_PS1_SHOWUPSTREAM="auto"
prompt="%{$fg[yellow]%}%n@%m %{$fg[blue]%}%~ %{$fg[green]%}${gitval}
%{$fg[red]%}$ %{$reset_color%}"
    fi;
}

# Aliases
alias l='ls -lhoG'
alias la='ls -laho'
alias ls='ls -G'
alias lsa='ls -Ga'
alias ta='tmux attach'

if [[ $(uname) == *CYGWIN* ]]
then
    alias l='ls --color -lho'
    alias la='ls --color -laho'
    alias ls='ls --color -G'
    alias lsa='ls --color -Ga'
fi

alias s='cd ..'
alias venv='source venv/bin/activate'
alias mkvenv='virtualenv venv'
alias ccat='pygmentize -O style=fruity,linenos=1 -f console256 -g'
alias im='vim'

if [[ $(uname) == *Darwin* ]] # Mac OS X
then
    alias vim='mvim -v'
    alias ctags="`brew --prefix`/bin/ctags"
fi

# More completions.
fpath=($zsh_config_dir/zsh-completions/src $fpath)

# case insensitive completion
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

zstyle ':completion:*' verbose yes
zstyle ':completion:*:descriptions' format '%B%d%b'
zstyle ':completion:*:messages' format '%d'
zstyle ':completion:*:warnings' format 'No matches for: %d'
zstyle ':completion:*' group-name ''
zstyle ':completion:*' completer _expand _complete _ignored

# generate descriptions with magic.
zstyle ':completion:*' auto-description 'specify: %d'

# Don't prompt for a huge list, page it.
zstyle ':completion:*:default' list-prompt '%S%M matches%s'

# Don't prompt for a huge list, menu it.
zstyle ':completion:*:default' menu 'select=0'

# Shift-tab goes back in the menu.
bindkey '^[[Z' reverse-menu-complete

# Have the newer files last so I see them first
zstyle ':completion:*' file-sort modification reverse

# Better directory completion
zstyle ':completion:*' special-dirs true

# Experiment with vi mode
function zle-line-init zle-keymap-select {
    #VIM_PROMPT="%{$fg_bold[yellow]%} [% NORMAL]%  %{$reset_color%}"
    RPS1="${${KEYMAP/vicmd/$VIM_PROMPT}/(main|viins)/}"
    zle reset-prompt
}

zle -N zle-line-init
zle -N zle-keymap-select
export KEYTIMEOUT=1
###-begin-npm-completion-###
#
# npm command completion script
#
# Installation: npm completion >> ~/.bashrc  (or ~/.zshrc)
# Or, maybe: npm completion > /usr/local/etc/bash_completion.d/npm
#

COMP_WORDBREAKS=${COMP_WORDBREAKS/=/}
COMP_WORDBREAKS=${COMP_WORDBREAKS/@/}
export COMP_WORDBREAKS

if type complete &>/dev/null; then
  _npm_completion () {
    local si="$IFS"
    IFS=$'\n' COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
                           COMP_LINE="$COMP_LINE" \
                           COMP_POINT="$COMP_POINT" \
                           npm completion -- "${COMP_WORDS[@]}" \
                           2>/dev/null)) || return $?
    IFS="$si"
  }
  complete -F _npm_completion npm
elif type compdef &>/dev/null; then
  _npm_completion() {
    si=$IFS
    compadd -- $(COMP_CWORD=$((CURRENT-1)) \
                 COMP_LINE=$BUFFER \
                 COMP_POINT=0 \
                 npm completion -- "${words[@]}" \
                 2>/dev/null)
    IFS=$si
  }
  compdef _npm_completion npm
elif type compctl &>/dev/null; then
  _npm_completion () {
    local cword line point words si
    read -Ac words
    read -cn cword
    let cword-=1
    read -l line
    read -ln point
    si="$IFS"
    IFS=$'\n' reply=($(COMP_CWORD="$cword" \
                       COMP_LINE="$line" \
                       COMP_POINT="$point" \
                       npm completion -- "${words[@]}" \
                       2>/dev/null)) || return $?
    IFS="$si"
  }
  compctl -K _npm_completion npm
fi
###-end-npm-completion-###
