# Nunchux Configuration
#
# Copy to: ~/.config/nunchux/config
# Fallback: ~/.nunchuxrc

[settings]
icon_running = ●
icon_stopped = ○
menu_width = 60%
menu_height = 50%
popup_width = 90%
popup_height = 90%
just_enabled = true
npm_enabled = false
fzf_prompt =
fzf_pointer = ▶
fzf_border = rounded
fzf_border_label =  nunchux
fzf_colors = fg+:white:bold,bg+:-1,hl:cyan,hl+:cyan:bold,pointer:cyan,marker:green,header:gray,border:gray
cache_ttl = 60

# A few words about cache_ttl
# ----------------------------
# Nunchux caches menus to make them open instantly. When you open a menu,
# you see the cached version right away while fresh data loads in the background.
# Once ready, the menu hot-swaps to show updated info.
#
# cache_ttl controls how long (in seconds) a cache is considered "fresh enough"
# to show instantly. After this time, the menu builds from scratch (with the
# nice streaming effect where items appear one by one).
#
# - In [settings]: sets the default for main menu and all submenus (default: 60)
# - In a submenu like [system]: overrides just that submenu
# - In a directory browser: controls that browser (default: 300 for dir browsers)
#
# Set to 0 to disable caching entirely for that menu.

[nonworking]
cmd = lkjdf

[git]
cmd = lazygit
status = cd "$(tmux display-message -p '#{pane_current_path}')"; \
         changed=$(git status -s 2>/dev/null | grep -vc '^??' | tr -d ' '); \
         untracked=$(git status -s 2>/dev/null | grep -c '^??' | tr -d ' '); \
         ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo 0); \
         behind=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo 0); \
         parts=(); \
         [[ $changed -gt 0 ]] && parts+=("${changed} changed"); \
         [[ $untracked -gt 0 ]] && parts+=("${untracked} untracked"); \
         [[ $ahead -gt 0 ]] && parts+=("↑${ahead}"); \
         [[ $behind -gt 0 ]] && parts+=("↓${behind}"); \
         if [[ ${#parts[@]} -gt 0 ]]; then IFS=", "; echo "(${parts[*]})"; else echo "(all up to date)"; fi

[docker]
cmd = lazydocker
status = n=$(docker ps -q 2>/dev/null | wc -l | tr -d ' '); [[ $n -gt 0 ]] && echo "($n running)"

[files]
cmd = nvim --clean -c 'set laststatus=0 cmdheight=0 noshowmode noruler signcolumn=no nonumber' -c 'terminal yazi --cwd-file={tmp}' -c 'startinsert' -c 'autocmd TermClose * qa!'
status = echo "($(tmux display-message -p '#{pane_current_path}' | sed "s|$HOME|~|"))"
height = 50
width = 60
on_exit = cwd=$(cat {tmp} 2>/dev/null); \
  if [[ -d "$cwd" ]]; then \
    cmd=$(tmux display-message -t {pane_id} -p '#{pane_current_command}'); \
    [[ "$cmd" =~ ^(bash|zsh|fish|sh)$ ]] && tmux send-keys -t {pane_id} "cd \"$cwd\"" Enter; \
  fi; \
  rm -f {tmp}

[todos]
cmd = nvim ~/todos.md
width = 70
height = 50
status = echo "(~/todos.md: $(lines ~/todos.md), $(ago ~/todos.md))"

# [config]
# cmd = nvim ~/.config/nunchux/config
# width = 80
# height = 70
# status = echo "($(ago ~/.config/nunchux/config))"

[config]
directory = ~/dotfiles
depth = 2
sort = modified-folder
sort_direction = descending
width = 90
height = 80
cache_ttl = 300

[notes]
cmd = bash -c 'f=$(nearest notes.md) && exec nvim "$f" || { echo "No notes.md found"; sleep 2; }'
width = 80
height = 60
status = f=$(nearest notes.md) && echo "(${f/#$HOME/\~}: $(lines "$f"), $(ago "$f"))"
on_exit = true

[calendar]
cmd = calcurse
width = 80
height = 70
status = next=$(calcurse -r7 2>/dev/null | awk '/^[0-9]/{d=$1;getline;if(/->/)t=$2;getline;m=$0;gsub(/^[[:space:]]+/,"",m);if(length(m)>40)m=substr(m,1,40)"...";print d,t,m;exit}'); [[ -n "$next" ]] && echo "($next)"

[todoist]
cmd = terminalist
desc = Tick things off
width = 80
height = 70

[hacker news]
cmd = hackernews_tui
desc = The front page of the internet (for nerds)

[reddix]
cmd = reddix
desc = Down the rabbit hole

# System submenu
[system]
status = load=$(cut -d' ' -f1 /proc/loadavg); \
         ram=$(awk '/MemAvailable/{printf "%.0f", $2/1024/1024}' /proc/meminfo); \
         disk=$(df /home --output=avail 2>/dev/null | tail -1 | awk '{printf "%.0f", $1/1024/1024}'); \
         wifi=$(iwgetid -r 2>/dev/null); \
         bat=$(acpi -b 2>/dev/null | head -1); \
         if [[ "$bat" == *Discharging* ]]; then bstat="| 󱊣 $(echo "$bat" | grep -oP '\d+:\d+(?=:\d+)')"; \
         elif [[ "$bat" == *Charging* ]]; then bstat="| 󱊣 $(echo "$bat" | grep -oP '\d+:\d+(?=:\d+)') ⚡"; \
         else bstat=''; fi; \
         wstat=""; [[ -n "$wifi" ]] && wstat="| 󰖩 $wifi "; \
         echo "󰍛 $load | 󰘚 ${ram}GB | 󰋜 ${disk}GB $wstat$bstat"

[system/btop]
cmd = btop
desc = Task manager

[system/impala]
cmd = impala
desc = WiFi manager

[system/wiremix]
cmd = wiremix
desc = Audio mixer

[system/hyprmon]
cmd = hyprmon
desc = Monitor settings

[system/bluetuith]
cmd = bluetuith
desc = Bluetooth manager

[system/bandwhich]
cmd = sudo bandwhich
desc = Bandwidth by process

[system/duf]
cmd = duf -only local | less -R
desc = Disk usage
width = 60
height = 30

[system/journalctl]
cmd = journalctl -f
desc = Follow system logs

[system/powertop]
cmd = sudo powertop
desc = Power consumption

[system/ncdu]
cmd = ncdu
desc = Disk usage analyzer

[system/nvtop]
cmd = nvtop
desc = GPU monitoring

[failme]
cmd = failme
desc = Test error handling

# vim: ft=dosini
